package entity;

// Start of user code for imports
import java.util.*;

import org.minueto.image.MinuetoImage;
import org.minueto.window.MinuetoWindow;
import game.Assets;
import map.*;
//End of user code

/**
 * Player class definition.
 * Generated by the TouchCORE code generator.
 */
public class Player extends DirectionedEntity {
    
    protected int score;
    protected int health;
    protected int attackDamage;
    protected int defence;
    protected int level;
    protected int experience;
    protected Weapon myWeapon;
    protected Armor myArmor;
    private int countKeysYellow;
    private int countKeysBlue;
    private int countKeysRed;
    
    public Player(String name, int x, int y, LevelMap m, Direction d) {
    	super(name, x, y, m, d);
        this.level = 1;
        this.experience = 0;
        this.attackDamage = 10;
        this.defence = 10;
        this.health = 100;
        this.score = 0;
        this.moveSpeed = 4;
    }
    
	protected void initiateAnimation() {
        MinuetoImage[][] playerSprites = new MinuetoImage[4][4];
        for (int i = 0; i < 4; i++) {
        	for (int j = 0; j < 4; j++) {
        		playerSprites[i][j] = Assets.getPlayerTexturesAt(i*4 + j);
        	}
        }
        DirectedAnimation playerAnimation = new DirectedAnimation(Direction.North, playerSprites[3], playerSprites[0], playerSprites[1], playerSprites[2]);
        this.setAnimation(playerAnimation);
	}
	
    Weapon getMyWeapon() {
        return this.myWeapon;
    }

    boolean setMyWeapon(Weapon newObject) {
        this.myWeapon = newObject;
        return true;
    }

    Armor getMyArmor() {
        return this.myArmor;
    }

    boolean setMyArmor(Armor newObject) {
        this.myArmor = newObject;
        return true;
    }

    public boolean equipWeapon(Weapon w) {
        if (myWeapon == null) {
            this.myWeapon = w;
            int damage = myWeapon.getDamage();
            this.attackDamage = attackDamage + damage;
            return true;
        }
        return false;
    }

    public boolean removeWeapon() {
        if (myWeapon!=null) {
            int weaponDamage = myWeapon.getDamage();
            this.attackDamage = attackDamage - weaponDamage;
            this.myWeapon = null;
            return true;
        }
        return false;
    }

    public boolean equipArmor(Armor a) {
        if (myArmor == null) {
            this.myArmor = a;
            int armor = myArmor.getDefence();
            this.defence = defence + armor;
            return true;
        }
        return false;
    }

    public boolean removeArmor() {
        if (myArmor!=null) {
            int armor = myArmor.getDefence();
            this.defence = defence - armor;
            this.myArmor = null;
            return true;
        }
        return false;
    }

    public int getSpeed() {
        if (myWeapon == null) {
            return 1;
        }
        int attackSpeed = myWeapon.getAttackSpeed();
        return attackSpeed;
    }

    public boolean getAttacked(int damage) {
        int realDamage = damage - defence;
        if (realDamage > 0) {
            this.health = health - realDamage;
        }
        if (health <= 0) {
            return false;
        }
        return true;
    }

    public int getDamage() {
        return this.attackDamage;
    }

    public boolean encounter(Entity e) {
        if (e == null) return true;
        else {
        	//TODO
        	return true;
        }
    }
    
    @Override
    public void move(Direction d) {
    	if (!moving) {
    		if (d != direction) this.setDirection(d);
    		if (nextPositionAvailable(d)) {
    			moving = true;
    			this.playAnimation();
    			boolean cameraMove = (this.positionX - this.levelMap.getCamX()) == 10 * 32 && (this.positionY - this.levelMap.getCamY()) == 7 * 32;
    	        if(d == Direction.North) {
    	        	this.setDest(this.getDestX(), this.getDestY()-32);
        			if (cameraMove) {
        				this.levelMap.setCamDest(this.levelMap.getCamX(), this.levelMap.getCamY()-32);
        			}
    	        }
    	        else if (d == Direction.South) {
    	        	this.setDest(this.getDestX(), this.getDestY()+32);
    	        	if (cameraMove) {
    	        		this.levelMap.setCamDest(this.levelMap.getCamX(), this.levelMap.getCamY()+32);
    	        	}
    	        }
    	        else if (d == Direction.East) {
    	        	this.setDest(this.getDestX()+32, this.getDestY());
    	        	if (cameraMove) {
    	        		this.levelMap.setCamDest(this.levelMap.getCamX()+32, this.levelMap.getCamY());
    	        	}
    	        }
    	        else if (d == Direction.West) {
    	        	this.setDest(this.getDestX()-32, this.getDestY());
    	        	if (cameraMove) {
        	        	this.levelMap.setCamDest(this.levelMap.getCamX()-32, this.levelMap.getCamY());
    	        	}
    	        }	
    		}
    	}
    }
    
    @Override
    public boolean nextPositionAvailable(Direction d) {
    	int col = this.positionX / 32;
    	int rol = this.positionY / 32;
    	Tile nextTile = null;
        if(d == Direction.North && rol > this.levelMap.getYmin() / 32) {
        	nextTile = this.levelMap.getTile(col, rol-1);
        }
        else if (d == Direction.South && rol < this.levelMap.getYmax() / 32) {
        	nextTile = this.levelMap.getTile(col, rol+1);
        }
        else if (d == Direction.East  && col < this.levelMap.getXmax() / 32) {
        	nextTile = this.levelMap.getTile(col+1, rol);
        }
        else if (d == Direction.West && col > this.levelMap.getXmin() / 32) {
        	nextTile = this.levelMap.getTile(col-1, rol);
        	
        }
        if (nextTile != null && nextTile.getType() == TileType.Ground) {
        	if (nextTile.getMyEntity() != null) {
        		return nextTile.getMyEntity().getEncountered(this);
        	}
        	else return true;
        }
        else return false;
    }
    
    @Override
    public void update() {
    	// update animation
        if (this.animation != null) {
            animation.update();
        }
        
		// get next position
    	if (moving) getNextPosition();
    	
    	// check stop moving
    	if ((this.positionX == this.destX && this.positionY == this.destY) && moving) {
    		moving = false;
    		this.stopAnimation();
    	}
    }
    
    public int getHealth(){
    	return this.health;
    }
    
    public int getDefence(){
    	return this.defence;
    }
    
    public int getExp(){
    	return this.experience;
    }
    
    public int getLvl(){
    	return this.level;
    }

	public boolean getEncountered(Player p) {
		return false;
	}
	
    public boolean changeOnKeys(int color, int number){
    	switch(color){
    	case 0: // yellow
    		if(this.countKeysYellow + number >= 0){
    			this.countKeysYellow += number;
    			return true;
    		}
    		break;
    	case 1:
    		if(this.countKeysBlue + number >= 0){
    			this.countKeysBlue += number;
    			return true;
    		}
    		break;
    	case 2:
    		if(this.countKeysRed + number >= 0){
    			this.countKeysRed += number;
    			return true;
    		}
    		break;
    	}
    	return false;
    }
    
    public int getKeyNum(int color){
    	switch(color){
    	case 0:
    		return this.countKeysYellow;
		case 1:
    		return this.countKeysBlue;
    	case 2:
    		return this.countKeysRed;
    	}
    	return 0;
    	
    }
}
